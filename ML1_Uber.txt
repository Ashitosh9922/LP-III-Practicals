# Import required libraries
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.preprocessing import StandardScaler
from sklearn.model_selection import train_test_split
from sklearn.metrics import mean_squared_error, r2_score, mean_absolute_error
from sklearn.linear_model import LinearRegression
from sklearn.ensemble import RandomForestRegressor

# Load dataset
df = pd.read_csv("C:/Users/Aishwarya/Downloads/uber.csv (1)/uber.csv")

# Check basic info
df.info()
df.isnull().sum()

# Boxplots for numeric columns (outlier check)
for col in df.select_dtypes(exclude=['object']):
    plt.figure()
    sns.boxplot(data=df, x=col)

# Remove invalid data (filter coordinates, fare, passenger count)
df = df[
    (df.pickup_latitude > -90) & (df.pickup_latitude < 90) &
    (df.dropoff_latitude > -90) & (df.dropoff_latitude < 90) &
    (df.pickup_longitude > -90) & (df.pickup_longitude < 90) &
    (df.dropoff_longitude > -90) & (df.dropoff_longitude < 90) &
    (df.fare_amount > 0) &
    (df.passenger_count > 0) & (df.passenger_count < 50)
]

# Function to calculate distance (Haversine formula)
def distance(lat1, lon1, lat2, lon2):
    lon1, lon2, lat1, lat2 = map(np.radians, [lon1, lon2, lat1, lat2])
    dlon, dlat = lon2 - lon1, lat2 - lat1
    km = 2 * 6371 * np.arcsin(np.sqrt(np.sin(dlat/2)**2 +
          np.cos(lat1) * np.cos(lat2) * np.sin(dlon/2)**2))
    return km

# Compute distance column
df['Distance'] = distance(df['pickup_latitude'], df['pickup_longitude'],
                          df['dropoff_latitude'], df['dropoff_longitude'])

# Keep only valid distances
df = df[(df['Distance'] > 0) & (df['Distance'] < 200)]

# Convert datetime and extract time features
df['pickup_datetime'] = pd.to_datetime(df['pickup_datetime'])
df['week_day'] = df['pickup_datetime'].dt.day_name()
df['Year'] = df['pickup_datetime'].dt.year
df['Month'] = df['pickup_datetime'].dt.month
df['Hour'] = df['pickup_datetime'].dt.hour

# Drop unused columns
df.drop(columns=['pickup_datetime','pickup_latitude','pickup_longitude',
                 'dropoff_latitude','dropoff_longitude'], inplace=True)

# Convert weekday to 0 (Weekday) or 1 (Weekend)
def convert_week_day(day):
    return 0 if day in ['Monday','Tuesday','Wednesday','Thursday'] else 1

# Convert hour to part of day
def convert_hour(hour):
    if 5 <= hour <= 12: return 1  # Morning
    elif 12 < hour <= 17: return 2  # Afternoon
    elif 17 < hour < 24: return 3  # Evening
    else: return 0  # Night

df['week_day'] = df['week_day'].apply(convert_week_day)
df['Hour'] = df['Hour'].apply(convert_hour)

# Correlation check
print(df.corr())

# Scatter plot (Fare vs Distance)
sns.scatterplot(x=df['Distance'], y=df['fare_amount'])

# Prepare features and target
X = df[['Distance']].values
y = df['fare_amount'].values.reshape(-1,1)

# Split data
x_train, x_test, y_train, y_test = train_test_split(X, y, random_state=10)

# Scale features and labels
sx, sy = StandardScaler(), StandardScaler()
x_train = sx.fit_transform(x_train)
x_test = sx.transform(x_test)
y_train = sy.fit_transform(y_train)
y_test = sy.transform(y_test)

# Function to train and evaluate models
def fit_predict(model):
    model.fit(x_train, y_train.ravel())
    y_pred = model.predict(x_test)
    print("RÂ²:", r2_score(y_test, y_pred))
    print("RMSE:", np.sqrt(mean_squared_error(y_test, y_pred)))
    print("MAE:", mean_absolute_error(y_test, y_pred))

# Linear Regression
print("\nLinear Regression Results:")
fit_predict(LinearRegression())

# Random Forest
print("\nRandom Forest Results:")
fit_predict(RandomForestRegressor())
